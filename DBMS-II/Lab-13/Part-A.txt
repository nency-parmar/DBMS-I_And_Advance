-- Part - A --

1. Create an index on the company field in the stocks collection.
db.Stock.createIndex({company:1},{name:"Company_Index"})

2. Create a compound index on the sector and sales fields in the stocks collection.
db.Stock.createIndex({sector:1,sales:1},{name:'Sector_Sales'})

3. List all the indexes created on the stocks collection.
db.Stock.getIndexes()

4. Drop an existing index on the company field from the stocks collection.
db.Stock.dropIndex({company:1},{name:'Company_Index'})

5. Use a cursor to retrieve and iterate over documents in the stocks collection, displaying each document.
var cursor_1 = db.Stock.find()

6. Limit the number of documents returned by a cursor to the first 3 documents in the stocks collection.
var cursor_2 = db.Stock.find().limit(3)

7. Sort the documents returned by a cursor in descending order based on the sales field.
var cursor_3 = db.Stock.find().sort({sales:-1})

8. Skip the first 2 documents in the result set and return the next documents using the cursor.
var cursor_4 = db.Stock.find().skip(2)

9. Convert the cursor to an array and return all documents from the stocks collection.
cursor_1.toArray()

10. Create a collection named "Companies" with schema validation to ensure that each document must
contains a company field (string) and a sector field (string).
db.createCollection("Companies",{
	validator:{
		$jsonSchema:{
			bsonType:"object",
			required: ["company","sector"],
			properties:{
				field_name:{
      		bsonType:"string",
					description: "Must Be a String And is Required"
}			
}
}
}
})


-- Part - B --

1. Create a collection named "Scripts" with validation for fields like eps, pe, and roe to ensure that they
are numbers and required/compulsory fields.
=> db.createCollection("Scripts",{
	validator:{
		$jsonSchema:{
			bsonType:"object",
			required: ["eps","pe","roe"],
			properties:{
				field_name:{
      		bsonType:"number",
					description: "Must Be Required Fields eps , pe , roe"
}			
}
}
}
})

2. Create a collection named "Products" where each product has an embedded document for
manufacturer details and a multivalued field for categories that stores an array of category names the
product belongs to.
 manufacturer details: The manufacturer will be an embedded document with fields like name,
country, and establishedYear.
 categories: The categories will be an array field that holds multiple values. (i.e. Electronics,
Mobile, Smart Devices).

=>
db.Products.insertMany([
  {
    name: "Samsung Galaxy S24",
    price: 899.99,
    manufacturer: {
      name: "Samsung",
      country: "South Korea",
      establishedYear: 1938
    },
    categories: ["Electronics", "Mobile", "Smart Devices"]
  },
  {
    name: "Sony Bravia OLED TV",
    price: 1999.99,
    manufacturer: {
      name: "Sony",
      country: "Japan",
      establishedYear: 1946
    },
    categories: ["Electronics", "TV", "Smart Devices"]
  }
]);


-- Part - C --

1. Create a collection named “financial
_Reports” that requires revenue (a positive number) but allows
optional fields like expenses and netIncome (if provided, they should also be numbers).
=>db.createCollection("financial_Reports", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["revenue"],  // revenue is required
      properties: {
        revenue: {
          bsonType: "double",
          minimum: 0.01,  // Must be a positive number
          description: "Required field: revenue must be a positive number"
        },
        expenses: {
          bsonType: ["double", "null"], // Optional but must be a number if provided
          description: "Optional field: expenses should be a number"
        },
        netIncome: {
          bsonType: ["double", "null"], // Optional but must be a number if provided
          description: "Optional field: netIncome should be a number"
        }
      }
    }
  }
});

2. Create a collection named "Student" where each student has name and address are embedded
document and mobilenumber and emailaddress are multivalued field that stores an array of values.
=>
db.Student.insertMany([
  {
    name: {
      firstName: "Alice",
      lastName: "Smith"
    },
    address: {
      street: "456 Elm St",
      city: "Los Angeles",
      zipCode: "90001"
    },
    mobileNumber: ["+1112223333"],
    emailAddress: ["alice.smith@example.com"]
  },
  {
    name: {
      firstName: "Bob",
      lastName: "Johnson"
    },
    address: {
      street: "789 Oak St",
      city: "Chicago",
      zipCode: "60601"
    },
    mobileNumber: ["+9876543210", "+1029384756"],
    emailAddress: ["bob.johnson@example.com", "bobj@gmail.com"]
  }
]);
